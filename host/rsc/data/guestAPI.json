{
  "memory": {
    "doc": "the wasm module should export its linear memory, rather than expecting to import it from the host (at the moment only 'exported' is valid)",
    "kind": "exported"
  },
  "functionExports": {
    "setup": {
      "doc": "called at startup; do whatever you need to do here but also reserve a block of memory for the engine to use later. also write 32 bytes to that memory: the first 26 a utf-8 string of the program name (null-terminated if length < 26) and then 3 u16s in a row indicating semver major.minor.patch",
      "paramsDoc": ["how many bytes of continguous memory to reserve for the host"],
      "returnDoc": "a pointer to where in the linear memory the reserved block begins",
      "paramsImp": ["usize"],
      "params": ["i32"],
      "returnImp": "usize",
      "return": "i32"
    },
    "receiveGameParams": {
      "doc": "called after the setup function; the initial game parameters (specced in `circumstances.json`) are currently sitting in the reserved memory block. they won't stay there, so copy out anything you need.",
      "paramsDoc": ["the offset in the shared memory where the parameters begin"],
      "returnDoc": "a boolean value saying whether or not we can proceed (if something in the parameters means we can't run, for example)",
      "paramsImp": ["usize"],
      "params": ["i32"],
      "returnImp": "boolean",
      "return": "i32"
    },
    "tick": {
      "doc": "a prompt from the engine for you to make your move; the current circumstances will be waiting for you in the reserved block",
      "paramsDoc": ["the offset in the shared memory where the circumstances begin"],
      "returnDoc": "",
      "paramsImp": ["usize"],
      "params": ["i32"],
      "returnImp": null,
      "return": null
    },
    "runFib": {
      "doc": "just for example purposes; calculate a Fibonacci number while reading and writing from shared memory",
      "paramsDoc": [
        "where in memory to find the single byte telling you which Fibonacci number to calculate",
        "the memory location to write the result as a u64"
      ],
      "returnDoc": "a boolean value saying whether the function was successful; if not it will have logged a reason",
      "paramsImp": ["usize", "usize"],
      "params": ["i32", "i32"],
      "returnImp": "boolean",
      "return": "i32"
    }
  },
  "functionImports": {
    "abort": {
      "doc": "NOT FOR GENERAL USE: only here because the AssemblyScript runtime demands it; at the moment just prints the error",
      "paramsDoc": ["AssemblyScript-internal pointer to the string to print", "AssemblyScript-internal pointer to path to the file where we're calling abort", "line where we're calling abort", "column where we're calling abort"],
      "returnDoc": "",
      "paramsImp": ["i32", "i32", "i32", "i32"],
      "params": ["i32", "i32", "i32", "i32"],
      "returnImp": null,
      "return": null
    },
    "logFunction": {
      "doc": "the engine's hook for logging; will print to either the terminal (if running from CLI) or the web console (if running in browser) or the visible UI (running in the frontend)",
      "paramsDoc": ["the log level; 0 = error, 1 = warn, 2 = log, 3 = info, 4 = debug", "the offset in the shared memory where the string to log begins", "length of the string"],
      "returnDoc": "",
      "paramsImp": ["u32", "usize", "usize"],
      "params": ["i32", "i32", "i32"],
      "return": null
    }
  }
}
