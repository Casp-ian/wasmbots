// This file was automatically generated by Beschi v0.2.0
// <https://github.com/sjml/beschi>
// Do not edit directly.

const std = @import("std");

const DataReaderError = error {
    EOF,
    InvalidData,
};

fn _numberTypeIsValid(comptime T: type) bool {
    const validNumericTypes = [_]type{
        bool,
        u8,  i8,
        u16, i16,
        u32, i32,
        u64, i64,
        f32, f64,
    };
    for (validNumericTypes) |vt| {
        if (T == vt) {
            return true;
        }
    }
    return false;
}

fn _typeIsSimple(comptime T: type) bool {
    if (comptime _numberTypeIsValid(T)) {
        return true;
    }
    const simpleTypes = [_]type{
        GameCircumstances, PlayerMove,
    };
    for (simpleTypes) |vt| {
        if (T == vt) {
            return true;
        }
    }
    return false;
}

pub fn readNumber(comptime T: type, offset: usize, buffer: []const u8) !struct { value: T, bytes_read: usize } {
    comptime {
        if (!_numberTypeIsValid(T)) {
            @compileError("Invalid number type");
        }
    }

    if (offset + @sizeOf(T) > buffer.len) {
        return DataReaderError.EOF;
    }

    switch (T) {
        f32 => return .{ .value = @bitCast(std.mem.readInt(u32, buffer[offset..][0..@sizeOf(T)], .little)), .bytes_read = @sizeOf(T) },
        f64 => return .{ .value = @bitCast(std.mem.readInt(u64, buffer[offset..][0..@sizeOf(T)], .little)), .bytes_read = @sizeOf(T) },
        bool => return .{ .value = std.mem.readInt(u8, buffer[offset..][0..@sizeOf(T)], .little) != 0, .bytes_read = @sizeOf(T) },
        else => return .{ .value = std.mem.readInt(T, buffer[offset..][0..@sizeOf(T)], .little), .bytes_read = @sizeOf(T) },
    }
}

pub fn readString(allocator: std.mem.Allocator, offset: usize, buffer: []const u8) !struct { value: []u8, bytes_read: usize } {
    const len_read = try readNumber(u8, offset, buffer);
    const len = len_read.value;

    if (offset + @sizeOf(u8) + len > buffer.len) {
        return DataReaderError.EOF;
    }

    var str = try allocator.alloc(u8, len);
    for (0..len) |i| {
        str[i] = buffer[offset + len_read.bytes_read + i];
    }
    return .{ .value = str, .bytes_read = @sizeOf(u8) + len };
}

pub fn readList(comptime T: type, allocator: std.mem.Allocator, offset: usize, buffer: []const u8) !struct { value: []T, bytes_read: usize } {
    var local_offset = offset;
    const len_read = try readNumber(u16, local_offset, buffer);
    const len = len_read.value;
    local_offset += len_read.bytes_read;
    var list = try allocator.alloc(T, len);
    var made_count: u16 = 0;

    errdefer {
        for (0..made_count) |i| {
            if (comptime _numberTypeIsValid(T)) {
                // no-op; just keeping the same structure as below
            }
            else {
                switch (T) {
                    []u8, []const u8 => {
                        allocator.free(list[i]);
                    },
                    else => {
                        if (comptime _typeIsSimple(T)) {
                            // no-op
                        }
                        else {
                            list[i].deinit(allocator);
                        }
                    }
                }
            }
        }
        allocator.free(list);
    }

    for (0..len) |i| {
        if (comptime _numberTypeIsValid(T)) {
            const list_read = try readNumber(T, local_offset, buffer);
            list[i] = list_read.value;
            local_offset += list_read.bytes_read;
        } else {
            switch (T) {
                []u8, []const u8 => {
                    const list_read = try readString(allocator, local_offset, buffer);
                    list[i] = list_read.value;
                    local_offset += list_read.bytes_read;
                },
                else => {
                    if (comptime _typeIsSimple(T)) {
                        const list_read = try T.fromBytes(local_offset, buffer);
                        list[i] = list_read.value;
                        local_offset += list_read.bytes_read;
                    }
                    else {
                        const list_read = try T.fromBytes(allocator, local_offset, buffer);
                        list[i] = list_read.value;
                        local_offset += list_read.bytes_read;
                    }
                },
            }
        }
        made_count += 1;
    }
    return .{ .value = list, .bytes_read = local_offset - offset };
}

pub fn writeNumber(comptime T: type, offset: usize, buffer: []u8, value: T) usize {
    comptime {
        if (!_numberTypeIsValid(T)) {
            @compileError("Invalid number type");
        }
    }

    const slice = buffer[offset..][0..@sizeOf(T)];
    switch (T) {
        f32 => std.mem.writeInt(u32, @constCast(slice), @bitCast(value), .little),
        f64 => std.mem.writeInt(u64, @constCast(slice), @bitCast(value), .little),
        bool => std.mem.writeInt(u8, @constCast(slice), @intFromBool(value), .little),
        else => std.mem.writeInt(T, @constCast(slice), value, .little),
    }
    return @sizeOf(T);
}

pub fn writeString(offset: usize, buffer: []u8, value: []const u8) usize {
    _ = writeNumber(u16, offset, buffer, @intCast(value.len));
    std.mem.copyForwards(u8, buffer[offset+@sizeOf(u16)..][0..value.len], value);
    return @sizeOf(u16) + value.len;
}

pub fn writeList(comptime T: type, offset: usize, buffer: []u8, value: []T) usize {
    var local_offset = offset;
    local_offset += writeNumber(u16, local_offset, buffer, @intCast(value.len));

    for (value) |item| {
        if (comptime _numberTypeIsValid(T)) {
            local_offset += writeNumber(T, local_offset, buffer, item);
        }
        else {
            switch(T) {
                []u8, []const u8 => {
                    local_offset += writeString(local_offset, buffer, item);
                },
                else => {
                    local_offset += item.writeBytes(local_offset, buffer);
                }
            }
        }
    }
    return local_offset - offset;
}

pub const MessageType = enum(u8) {
    GameCircumstances,
    PlayerMove,
};

pub const Message = union(MessageType) {
    GameCircumstances: GameCircumstances,
    PlayerMove: PlayerMove,
};

pub fn processRawBytes(allocator: std.mem.Allocator, buffer: []const u8) ![]Message {
    var msg_list = std.ArrayList(Message).init(allocator);
    defer msg_list.deinit();

    var local_offset: usize = 0;
    while (local_offset < buffer.len) {
        const msg_type_byte = (try readNumber(u8, local_offset, buffer)).value;
        local_offset += 1;
        const msg_type: MessageType = std.meta.intToEnum(MessageType, msg_type_byte - 1) catch return DataReaderError.InvalidData;
        switch(msg_type) {
            .GameCircumstances => {
                const msg_read = try GameCircumstances.fromBytes(local_offset, buffer);
                local_offset += msg_read.bytes_read;
                try msg_list.append(Message{ .GameCircumstances = msg_read.value });
            },
            .PlayerMove => {
                const msg_read = try PlayerMove.fromBytes(local_offset, buffer);
                local_offset += msg_read.bytes_read;
                try msg_list.append(Message{ .PlayerMove = msg_read.value });
            },
        }
    }
    return msg_list.toOwnedSlice();
}

pub const GameCircumstances = struct {
    lastTickDuration: u32 = 0,
    lastMoveSucceeded: bool = false,

    pub fn getSizeInBytes(self: *const GameCircumstances) usize {
        _ = self;
        return 5;
    }

    pub fn fromBytes(offset: usize, buffer: []const u8) !struct { value: GameCircumstances, bytes_read: usize } {
        const GameCircumstances_lastTickDuration = (try readNumber(u32, offset + 0, buffer)).value;
        const GameCircumstances_lastMoveSucceeded = (try readNumber(bool, offset + 4, buffer)).value;
        return .{ .value = GameCircumstances{
            .lastTickDuration = GameCircumstances_lastTickDuration,
            .lastMoveSucceeded = GameCircumstances_lastMoveSucceeded,
        }, .bytes_read = 5 };
    }

    pub fn writeBytes(self: *const GameCircumstances, offset: usize, buffer: []u8, tag: bool) usize {
        var local_offset = offset;

        if (tag) {
            local_offset += writeNumber(u8, local_offset, buffer, 1);
        }
        local_offset += writeNumber(u32, local_offset, buffer, self.lastTickDuration);
        local_offset += writeNumber(bool, local_offset, buffer, self.lastMoveSucceeded);

        return local_offset - offset;
    }
};

pub const PlayerMove = struct {
    moveByte: u8 = 0,

    pub fn getSizeInBytes(self: *const PlayerMove) usize {
        _ = self;
        return 1;
    }

    pub fn fromBytes(offset: usize, buffer: []const u8) !struct { value: PlayerMove, bytes_read: usize } {
        const PlayerMove_moveByte = (try readNumber(u8, offset + 0, buffer)).value;
        return .{ .value = PlayerMove{
            .moveByte = PlayerMove_moveByte,
        }, .bytes_read = 1 };
    }

    pub fn writeBytes(self: *const PlayerMove, offset: usize, buffer: []u8, tag: bool) usize {
        var local_offset = offset;

        if (tag) {
            local_offset += writeNumber(u8, local_offset, buffer, 2);
        }
        local_offset += writeNumber(u8, local_offset, buffer, self.moveByte);

        return local_offset - offset;
    }
};

