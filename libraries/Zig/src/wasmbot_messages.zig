// This file was automatically generated by Beschi v0.2.0
// <https://github.com/sjml/beschi>
// Do not edit directly.

const std = @import("std");

const DataReaderError = error {
    EOF,
    InvalidData,
};

fn _numberTypeIsValid(comptime T: type) bool {
    const validNumericTypes = [_]type{
        bool,
        u8,  i8,
        u16, i16,
        u32, i32,
        u64, i64,
        f32, f64,
    };
    for (validNumericTypes) |vt| {
        if (T == vt) {
            return true;
        }
    }
    return false;
}

fn _typeIsSimple(comptime T: type) bool {
    if (comptime _numberTypeIsValid(T)) {
        return true;
    }
    const simpleTypes = [_]type{
        InitialParameters, Wait, Resign, Move,
    };
    for (simpleTypes) |vt| {
        if (T == vt) {
            return true;
        }
    }
    return false;
}

pub fn readNumber(comptime T: type, offset: usize, buffer: []const u8) !struct { value: T, bytes_read: usize } {
    comptime {
        if (!_numberTypeIsValid(T)) {
            @compileError("Invalid number type");
        }
    }

    if (offset + @sizeOf(T) > buffer.len) {
        return DataReaderError.EOF;
    }

    switch (T) {
        f32 => return .{ .value = @bitCast(std.mem.readInt(u32, buffer[offset..][0..@sizeOf(T)], .little)), .bytes_read = @sizeOf(T) },
        f64 => return .{ .value = @bitCast(std.mem.readInt(u64, buffer[offset..][0..@sizeOf(T)], .little)), .bytes_read = @sizeOf(T) },
        bool => return .{ .value = std.mem.readInt(u8, buffer[offset..][0..@sizeOf(T)], .little) != 0, .bytes_read = @sizeOf(T) },
        else => return .{ .value = std.mem.readInt(T, buffer[offset..][0..@sizeOf(T)], .little), .bytes_read = @sizeOf(T) },
    }
}

pub fn readString(allocator: std.mem.Allocator, offset: usize, buffer: []const u8) !struct { value: []u8, bytes_read: usize } {
    const len_read = try readNumber(u8, offset, buffer);
    const len = len_read.value;

    if (offset + @sizeOf(u8) + len > buffer.len) {
        return DataReaderError.EOF;
    }

    var str = try allocator.alloc(u8, len);
    for (0..len) |i| {
        str[i] = buffer[offset + len_read.bytes_read + i];
    }
    return .{ .value = str, .bytes_read = @sizeOf(u8) + len };
}

pub fn readList(comptime T: type, allocator: std.mem.Allocator, offset: usize, buffer: []const u8) !struct { value: []T, bytes_read: usize } {
    var local_offset = offset;
    const len_read = try readNumber(u16, local_offset, buffer);
    const len = len_read.value;
    local_offset += len_read.bytes_read;
    var list = try allocator.alloc(T, len);
    var made_count: u16 = 0;

    errdefer {
        for (0..made_count) |i| {
            if (comptime _numberTypeIsValid(T)) {
                // no-op; just keeping the same structure as below
            }
            else {
                switch (T) {
                    []u8, []const u8 => {
                        allocator.free(list[i]);
                    },
                    else => {
                        if (comptime _typeIsSimple(T)) {
                            // no-op
                        }
                        else {
                            list[i].deinit(allocator);
                        }
                    }
                }
            }
        }
        allocator.free(list);
    }

    for (0..len) |i| {
        if (comptime _numberTypeIsValid(T)) {
            const list_read = try readNumber(T, local_offset, buffer);
            list[i] = list_read.value;
            local_offset += list_read.bytes_read;
        } else {
            switch (T) {
                []u8, []const u8 => {
                    const list_read = try readString(allocator, local_offset, buffer);
                    list[i] = list_read.value;
                    local_offset += list_read.bytes_read;
                },
                else => {
                    if (comptime _typeIsSimple(T)) {
                        const list_read = try T.fromBytes(local_offset, buffer);
                        list[i] = list_read.value;
                        local_offset += list_read.bytes_read;
                    }
                    else {
                        const list_read = try T.fromBytes(allocator, local_offset, buffer);
                        list[i] = list_read.value;
                        local_offset += list_read.bytes_read;
                    }
                },
            }
        }
        made_count += 1;
    }
    return .{ .value = list, .bytes_read = local_offset - offset };
}

pub fn writeNumber(comptime T: type, offset: usize, buffer: []u8, value: T) usize {
    comptime {
        if (!_numberTypeIsValid(T)) {
            @compileError("Invalid number type");
        }
    }

    const slice = buffer[offset..][0..@sizeOf(T)];
    switch (T) {
        f32 => std.mem.writeInt(u32, @constCast(slice), @bitCast(value), .little),
        f64 => std.mem.writeInt(u64, @constCast(slice), @bitCast(value), .little),
        bool => std.mem.writeInt(u8, @constCast(slice), @intFromBool(value), .little),
        else => std.mem.writeInt(T, @constCast(slice), value, .little),
    }
    return @sizeOf(T);
}

pub fn writeString(offset: usize, buffer: []u8, value: []const u8) usize {
    _ = writeNumber(u16, offset, buffer, @intCast(value.len));
    std.mem.copyForwards(u8, buffer[offset+@sizeOf(u16)..][0..value.len], value);
    return @sizeOf(u16) + value.len;
}

pub fn writeList(comptime T: type, offset: usize, buffer: []u8, value: []T) usize {
    var local_offset = offset;
    local_offset += writeNumber(u16, local_offset, buffer, @intCast(value.len));

    for (value) |item| {
        if (comptime _numberTypeIsValid(T)) {
            local_offset += writeNumber(T, local_offset, buffer, item);
        }
        else {
            switch(T) {
                []u8, []const u8 => {
                    local_offset += writeString(local_offset, buffer, item);
                },
                else => {
                    local_offset += item.writeBytes(local_offset, buffer);
                }
            }
        }
    }
    return local_offset - offset;
}

pub fn writeBytes(m: *const Message, offset: usize, buffer: []u8, tag: bool) usize {
    switch (m.*) {
        inline else => |inner| return inner.writeBytes(offset, buffer, tag),
    }
}

pub const MessageType = enum(u8) {
    _Error,
    InitialParameters,
    PresentCircumstances,
    Wait,
    Resign,
    Move,
};

pub const Message = union(MessageType) {
    _Error: _Error,
    InitialParameters: InitialParameters,
    PresentCircumstances: PresentCircumstances,
    Wait: Wait,
    Resign: Resign,
    Move: Move,
};

pub fn processRawBytes(allocator: std.mem.Allocator, buffer: []const u8) ![]Message {
    var msg_list = std.ArrayList(Message).init(allocator);
    defer msg_list.deinit();

    var local_offset: usize = 0;
    while (local_offset < buffer.len) {
        const msg_type_byte = (try readNumber(u8, local_offset, buffer)).value;
        local_offset += 1;
        if (msg_type_byte == 0) {
            return msg_list.toOwnedSlice();
        }
        const msg_type: MessageType = std.meta.intToEnum(MessageType, msg_type_byte - 1) catch return DataReaderError.InvalidData;
        switch(msg_type) {
            ._Error => {
                const msg_read = try _Error.fromBytes(allocator, local_offset, buffer);
                local_offset += msg_read.bytes_read;
                try msg_list.append(Message{ ._Error = msg_read.value });
            },
            .InitialParameters => {
                const msg_read = try InitialParameters.fromBytes(local_offset, buffer);
                local_offset += msg_read.bytes_read;
                try msg_list.append(Message{ .InitialParameters = msg_read.value });
            },
            .PresentCircumstances => {
                const msg_read = try PresentCircumstances.fromBytes(allocator, local_offset, buffer);
                local_offset += msg_read.bytes_read;
                try msg_list.append(Message{ .PresentCircumstances = msg_read.value });
            },
            .Wait => {
                const msg_read = try Wait.fromBytes(local_offset, buffer);
                local_offset += msg_read.bytes_read;
                try msg_list.append(Message{ .Wait = msg_read.value });
            },
            .Resign => {
                const msg_read = try Resign.fromBytes(local_offset, buffer);
                local_offset += msg_read.bytes_read;
                try msg_list.append(Message{ .Resign = msg_read.value });
            },
            .Move => {
                const msg_read = try Move.fromBytes(local_offset, buffer);
                local_offset += msg_read.bytes_read;
                try msg_list.append(Message{ .Move = msg_read.value });
            },
        }
    }
    return msg_list.toOwnedSlice();
}

pub const _Error = struct {
    description: []const u8 = "",

    pub fn getSizeInBytes(self: *const _Error) usize {
        var size: usize = 0;
        size += self.description.len;
        size += 1;
        return size;
    }

    pub fn fromBytes(allocator: std.mem.Allocator, offset: usize, buffer: []const u8) !struct { value: _Error, bytes_read: usize } {
        var local_offset = offset;

        const _Error_description_read = try readString(allocator, local_offset, buffer);
        const _Error_description = _Error_description_read.value;
        local_offset += _Error_description_read.bytes_read;

        return .{ .value = _Error{
            .description = _Error_description,
        }, .bytes_read = local_offset - offset };
    }

    pub fn writeBytes(self: *const _Error, offset: usize, buffer: []u8, tag: bool) usize {
        var local_offset = offset;
        if (tag) {
            local_offset += writeNumber(u8, local_offset, buffer, 1);
        }

        local_offset += writeString(local_offset, buffer, self.description);

        return local_offset - offset;
    }

    pub fn deinit(self: *_Error, allocator: std.mem.Allocator) void {
        allocator.free(self.description);
    }
};

pub const InitialParameters = struct {
    paramsVersion: u16 = 0,
    engineVersionMajor: u16 = 0,
    engineVersionMinor: u16 = 0,
    engineVersionPatch: u16 = 0,

    pub fn getSizeInBytes(self: *const InitialParameters) usize {
        _ = self;
        return 8;
    }

    pub fn fromBytes(offset: usize, buffer: []const u8) !struct { value: InitialParameters, bytes_read: usize } {
        const InitialParameters_paramsVersion = (try readNumber(u16, offset + 0, buffer)).value;
        const InitialParameters_engineVersionMajor = (try readNumber(u16, offset + 2, buffer)).value;
        const InitialParameters_engineVersionMinor = (try readNumber(u16, offset + 4, buffer)).value;
        const InitialParameters_engineVersionPatch = (try readNumber(u16, offset + 6, buffer)).value;
        return .{ .value = InitialParameters{
            .paramsVersion = InitialParameters_paramsVersion,
            .engineVersionMajor = InitialParameters_engineVersionMajor,
            .engineVersionMinor = InitialParameters_engineVersionMinor,
            .engineVersionPatch = InitialParameters_engineVersionPatch,
        }, .bytes_read = 8 };
    }

    pub fn writeBytes(self: *const InitialParameters, offset: usize, buffer: []u8, tag: bool) usize {
        var local_offset = offset;

        if (tag) {
            local_offset += writeNumber(u8, local_offset, buffer, 2);
        }
        local_offset += writeNumber(u16, local_offset, buffer, self.paramsVersion);
        local_offset += writeNumber(u16, local_offset, buffer, self.engineVersionMajor);
        local_offset += writeNumber(u16, local_offset, buffer, self.engineVersionMinor);
        local_offset += writeNumber(u16, local_offset, buffer, self.engineVersionPatch);

        return local_offset - offset;
    }
};

pub const PresentCircumstances = struct {
    lastTickDuration: u32 = 0,
    lastMoveSucceeded: bool = false,
    currentHitPoints: u16 = 0,
    currentStatus: u8 = 0,
    surroundings: []u16 = &.{},
    surroundingsRadius: u8 = 0,

    pub fn getSizeInBytes(self: *const PresentCircumstances) usize {
        var size: usize = 0;
        size += self.surroundings.len * 2;
        size += 11;
        return size;
    }

    pub fn fromBytes(allocator: std.mem.Allocator, offset: usize, buffer: []const u8) !struct { value: PresentCircumstances, bytes_read: usize } {
        var local_offset = offset;

        const PresentCircumstances_lastTickDuration_read = try readNumber(u32, local_offset, buffer);
        const PresentCircumstances_lastTickDuration = PresentCircumstances_lastTickDuration_read.value;
        local_offset += PresentCircumstances_lastTickDuration_read.bytes_read;

        const PresentCircumstances_lastMoveSucceeded_read = try readNumber(bool, local_offset, buffer);
        const PresentCircumstances_lastMoveSucceeded = PresentCircumstances_lastMoveSucceeded_read.value;
        local_offset += PresentCircumstances_lastMoveSucceeded_read.bytes_read;

        const PresentCircumstances_currentHitPoints_read = try readNumber(u16, local_offset, buffer);
        const PresentCircumstances_currentHitPoints = PresentCircumstances_currentHitPoints_read.value;
        local_offset += PresentCircumstances_currentHitPoints_read.bytes_read;

        const PresentCircumstances_currentStatus_read = try readNumber(u8, local_offset, buffer);
        const PresentCircumstances_currentStatus = PresentCircumstances_currentStatus_read.value;
        local_offset += PresentCircumstances_currentStatus_read.bytes_read;

        const PresentCircumstances_surroundings_read = try readList(u16, allocator, local_offset, buffer);
        const PresentCircumstances_surroundings = PresentCircumstances_surroundings_read.value;
        local_offset += PresentCircumstances_surroundings_read.bytes_read;

        const PresentCircumstances_surroundingsRadius_read = try readNumber(u8, local_offset, buffer);
        const PresentCircumstances_surroundingsRadius = PresentCircumstances_surroundingsRadius_read.value;
        local_offset += PresentCircumstances_surroundingsRadius_read.bytes_read;

        return .{ .value = PresentCircumstances{
            .lastTickDuration = PresentCircumstances_lastTickDuration,
            .lastMoveSucceeded = PresentCircumstances_lastMoveSucceeded,
            .currentHitPoints = PresentCircumstances_currentHitPoints,
            .currentStatus = PresentCircumstances_currentStatus,
            .surroundings = PresentCircumstances_surroundings,
            .surroundingsRadius = PresentCircumstances_surroundingsRadius,
        }, .bytes_read = local_offset - offset };
    }

    pub fn writeBytes(self: *const PresentCircumstances, offset: usize, buffer: []u8, tag: bool) usize {
        var local_offset = offset;
        if (tag) {
            local_offset += writeNumber(u8, local_offset, buffer, 3);
        }

        local_offset += writeNumber(u32, local_offset, buffer, self.lastTickDuration);
        local_offset += writeNumber(bool, local_offset, buffer, self.lastMoveSucceeded);
        local_offset += writeNumber(u16, local_offset, buffer, self.currentHitPoints);
        local_offset += writeNumber(u8, local_offset, buffer, self.currentStatus);
        local_offset += writeList(u16, local_offset, buffer, self.surroundings);
        local_offset += writeNumber(u8, local_offset, buffer, self.surroundingsRadius);

        return local_offset - offset;
    }

    pub fn deinit(self: *PresentCircumstances, allocator: std.mem.Allocator) void {
        allocator.free(self.surroundings);
    }
};

pub const Wait = struct {

    pub fn getSizeInBytes(self: *const Wait) usize {
        _ = self;
        return 0;
    }

    pub fn fromBytes(offset: usize, buffer: []const u8) !struct { value: Wait, bytes_read: usize } {
        _ = offset;
        _ = buffer;
        return .{ .value = Wait{
        }, .bytes_read = 0 };
    }

    pub fn writeBytes(self: *const Wait, offset: usize, buffer: []u8, tag: bool) usize {
        _ = self;
        var local_offset = offset;

        if (tag) {
            local_offset += writeNumber(u8, local_offset, buffer, 4);
        }

        return local_offset - offset;
    }
};

pub const Resign = struct {

    pub fn getSizeInBytes(self: *const Resign) usize {
        _ = self;
        return 0;
    }

    pub fn fromBytes(offset: usize, buffer: []const u8) !struct { value: Resign, bytes_read: usize } {
        _ = offset;
        _ = buffer;
        return .{ .value = Resign{
        }, .bytes_read = 0 };
    }

    pub fn writeBytes(self: *const Resign, offset: usize, buffer: []u8, tag: bool) usize {
        _ = self;
        var local_offset = offset;

        if (tag) {
            local_offset += writeNumber(u8, local_offset, buffer, 5);
        }

        return local_offset - offset;
    }
};

pub const Move = struct {
    direction: u8 = 0,
    distance: u8 = 0,

    pub fn getSizeInBytes(self: *const Move) usize {
        _ = self;
        return 2;
    }

    pub fn fromBytes(offset: usize, buffer: []const u8) !struct { value: Move, bytes_read: usize } {
        const Move_direction = (try readNumber(u8, offset + 0, buffer)).value;
        const Move_distance = (try readNumber(u8, offset + 1, buffer)).value;
        return .{ .value = Move{
            .direction = Move_direction,
            .distance = Move_distance,
        }, .bytes_read = 2 };
    }

    pub fn writeBytes(self: *const Move, offset: usize, buffer: []u8, tag: bool) usize {
        var local_offset = offset;

        if (tag) {
            local_offset += writeNumber(u8, local_offset, buffer, 6);
        }
        local_offset += writeNumber(u8, local_offset, buffer, self.direction);
        local_offset += writeNumber(u8, local_offset, buffer, self.distance);

        return local_offset - offset;
    }
};

